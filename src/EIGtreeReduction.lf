target C

preamble {=
    struct tuple {
        char key[32 + 1];
        char value[64 + 1];
        uint64_t time;
    };
=}

reactor EIGtreeReduction {
    input round0_in: tuple;
    input p0p1_in: tuple;
    input p0p2_in: tuple;
    input p0p3_in: tuple;
    input p0p1p2_in: tuple;
    input p0p1p3_in: tuple;
    input p0p2p1_in: tuple;
    input p0p2p3_in: tuple;
    input p0p3p1_in: tuple;
    input p0p3p2_in: tuple;

    output final_out: tuple;

    reaction(round0_in, p0p1_in, p0p2_in, p0p3_in,
         p0p1p2_in, p0p1p3_in, p0p2p1_in, p0p2p3_in,
         p0p3p1_in, p0p3p2_in) -> final_out {=

        if (is_present(round0_in) &&
            is_present(p0p1_in) && is_present(p0p2_in) && is_present(p0p3_in) &&
            is_present(p0p1p2_in) && is_present(p0p1p3_in) &&
            is_present(p0p2p1_in) && is_present(p0p2p3_in) &&
            is_present(p0p3p1_in) && is_present(p0p3p2_in)) {
            tuple inputs[10] = {
                round0_in, p0p1_in, p0p2_in, p0p3_in,
                p0p1p2_in, p0p1p3_in, p0p2p1_in, p0p2p3_in,
                p0p3p1_in, p0p3p2_in
            };

            struct {
                char value[65];
                int count;
                int first_index;
            } tally[10];

            int unique_count = 0;

            for (int i = 0; i < 10; i++) {
                int found = 0;
                for (int j = 0; j < unique_count; j++) {
                    if (strcmp(inputs[i].value, tally[j].value) == 0) {
                        tally[j].count++;
                        if (inputs[i].time > tally[j].latest_time) {
                            tally[j].latest_time = inputs[i].time;
                            tally[j].first_index = i;
                        }
                        found = 1;
                        break;
                    }
                }

                if (!found) {
                    strcpy(tally[unique_count].value, inputs[i].value);
                    tally[unique_count].count = 1;
                    tally[unique_count].latest_time = inputs[i].time;
                    tally[unique_count].first_index = i;
                    unique_count++;
                }
            }

            int max_count = 0;
            int best_index = 0;
            for (int i = 0; i < unique_count; i++) {
                if (tally[i].count > max_count) {
                    max_count = tally[i].count;
                    best_index = tally[i].first_index;
                }
            }
            lf_set(final_out, inputs[best_index]);
        }
    =}
}

// Code generated by the Lingua Franca compiler from:
// file://mnt/c/Users/32739/LF/LF-InConcReTeS/fed-gen/inverted_pendulum/src/federate__s3.lf
#define LOG_LEVEL 2

#include <limits.h>
#include "low_level_platform/api/low_level_platform.h"
#include "include/api/schedule.h"
#include "include/core/reactor.h"
#include "include/core/reactor_common.h"
#include "include/core/threaded/scheduler.h"
#include "trace/api/trace.h"
#include "include/core/mixed_radix.h"
#include "include/core/port.h"
#include "include/core/environment.h"
int lf_reactor_c_main(int argc, const char* argv[]);
#include "include/core/federated/federate.h"
#include "include/core/federated/network/net_common.h"
int main(int argc, const char* argv[]) {
    return lf_reactor_c_main(argc, argv);
}
const char* _lf_default_argv[] = { "dummy", "-k", "true", "-o", "100", "sec" };
void lf_set_default_command_line_options() {
        default_argc = 6;
        default_argv = _lf_default_argv;
}
#include "_sensor.h"
#include "_networksender_0_0.h"
#include "_networksender_1_1.h"
#include "_networksender_2_2.h"
#include "_networksender_3_3.h"
#include "_networksender_4_4.h"
#include "_networksender_5_5.h"
#include "_networkreceiver_148.h"
#include "_networkreceiver_149.h"
#include "_networkreceiver_150.h"
#include "_networkreceiver_151.h"
#include "__s3ap_in.h"
#include "__s3av_in.h"
#include "__s3cp_in.h"
#include "__s3cv_in.h"
#include "_federate__s3_main.h"
typedef enum {
    federate__s3_main,
    _num_enclaves
} _enclave_id;
// The global array of environments associated with each enclave
environment_t envs[_num_enclaves];
// 'Create' and initialize the environments in the program
void lf_create_environments() {
    environment_init(&envs[federate__s3_main],"federate__s3",federate__s3_main,_lf_number_of_workers,1,6,0,0,14,0,0,0,"federate__s3.lft");
}
// Update the pointer argument to point to the beginning of the environment array
// and return the size of that array
int _lf_get_environments(environment_t ** return_envs) {
   (*return_envs) = (environment_t *) envs;
   return _num_enclaves;
}
#include "include/_federate__s3_preamble.h"
void _lf_initialize_trigger_objects() {
    int startup_reaction_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(startup_reaction_count);
    int shutdown_reaction_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(shutdown_reaction_count);
    int reset_reaction_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(reset_reaction_count);
    int timer_triggers_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(timer_triggers_count);
    int modal_state_reset_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(modal_state_reset_count);
    int modal_reactor_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(modal_reactor_count);
    int watchdog_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(watchdog_count);
    int bank_index;
    SUPPRESS_UNUSED_WARNING(bank_index);
    int watchdog_number = 0;
    SUPPRESS_UNUSED_WARNING(watchdog_number);
    _federate__s3_main_main_self_t* federate__s3_main_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3_main_self);
    _sensor_self_t* federate__s3_s3_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3_s3_self);
    _networksender_0_0_self_t* federate__s3_ns_federate__p3_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3_ns_federate__p3_self);
    _networksender_1_1_self_t* federate__s3_ns_federate__p3_0_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3_ns_federate__p3_0_self);
    _networksender_2_2_self_t* federate__s3_ns_federate__p3_1_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3_ns_federate__p3_1_self);
    _networksender_3_3_self_t* federate__s3_ns_federate__p3_2_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3_ns_federate__p3_2_self);
    _networksender_4_4_self_t* federate__s3_ns_federate__plant_1_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3_ns_federate__plant_1_self);
    _networksender_5_5_self_t* federate__s3_ns_federate__p3_3_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3_ns_federate__p3_3_self);
    _networkreceiver_148_self_t* federate__s3_nr_federate__s3_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3_nr_federate__s3_self);
    _networkreceiver_149_self_t* federate__s3_nr_federate__s3_0_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3_nr_federate__s3_0_self);
    _networkreceiver_150_self_t* federate__s3_nr_federate__s3_1_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3_nr_federate__s3_1_self);
    _networkreceiver_151_self_t* federate__s3_nr_federate__s3_2_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3_nr_federate__s3_2_self);
    __s3ap_in_self_t* federate__s3__s3ap_in0_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3__s3ap_in0_self);
    __s3av_in_self_t* federate__s3__s3av_in0_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3__s3av_in0_self);
    __s3cp_in_self_t* federate__s3__s3cp_in0_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3__s3cp_in0_self);
    __s3cv_in_self_t* federate__s3__s3cv_in0_self[1];
    SUPPRESS_UNUSED_WARNING(federate__s3__s3cv_in0_self);
    // ***** Start initializing federate__s3 of class federate__s3
    federate__s3_main_self[0] = new__federate__s3_main();
    federate__s3_main_self[0]->base.environment = &envs[federate__s3_main];
    _lf_register_trace_event(federate__s3_main_self[0], NULL, trace_reactor, "federate__s3");
    bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
    
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3.s3 of class Sensor
        federate__s3_s3_self[0] = new__sensor();
        federate__s3_s3_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3_s3_self[0], NULL, trace_reactor, "s3");
        _lf_register_trace_event(federate__s3_s3_self[0], &(federate__s3_s3_self[0]->_lf__t), trace_trigger, "s3.t");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        // width of -2 indicates that it is not a multiport.
        federate__s3_s3_self[0]->_lf_AP_out_width = -2;
        // width of -2 indicates that it is not a multiport.
        federate__s3_s3_self[0]->_lf_AV_out_width = -2;
        // width of -2 indicates that it is not a multiport.
        federate__s3_s3_self[0]->_lf_CP_out_width = -2;
        // width of -2 indicates that it is not a multiport.
        federate__s3_s3_self[0]->_lf_CV_out_width = -2;
        // width of -2 indicates that it is not a multiport.
        federate__s3_s3_self[0]->_lf_request_width = -2;
        // width of -2 indicates that it is not a multiport.
        federate__s3_s3_self[0]->_lf_sim_start_time_width = -2;
        // width of -2 indicates that it is not a multiport.
        federate__s3_s3_self[0]->_lf_AP_in_width = -2;
        // width of -2 indicates that it is not a multiport.
        federate__s3_s3_self[0]->_lf_AV_in_width = -2;
        // width of -2 indicates that it is not a multiport.
        federate__s3_s3_self[0]->_lf_CP_in_width = -2;
        // width of -2 indicates that it is not a multiport.
        federate__s3_s3_self[0]->_lf_CV_in_width = -2;
        // Initiaizing timer federate__s3.s3.t.
        federate__s3_s3_self[0]->_lf__t.offset = 0;
        federate__s3_s3_self[0]->_lf__t.period = MSEC(10);
        // Associate timer with the environment of its parent
        envs[federate__s3_main].timer_triggers[timer_triggers_count[federate__s3_main]++] = &federate__s3_s3_self[0]->_lf__t;
        federate__s3_s3_self[0]->_lf__t.mode = NULL;
    
        federate__s3_s3_self[0]->_lf__reaction_0.deadline = NEVER;
        federate__s3_s3_self[0]->_lf__reaction_1.deadline = NEVER;
        federate__s3_s3_self[0]->_lf__reaction_2.deadline = NEVER;
        federate__s3_s3_self[0]->_lf__reaction_3.deadline = NEVER;
        federate__s3_s3_self[0]->_lf__reaction_4.deadline = NEVER;
        //***** End initializing federate__s3.s3
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3.ns_federate__p3 of class NetworkSender_0
        federate__s3_ns_federate__p3_self[0] = new__networksender_0_0();
        federate__s3_ns_federate__p3_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3_ns_federate__p3_self[0], NULL, trace_reactor, "ns_federate__p3");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        federate__s3_ns_federate__p3_self[0]->_lf_msg_width = 1;
        // Allocate memory for multiport inputs.
        federate__s3_ns_federate__p3_self[0]->_lf_msg = (_networksender_0_0_msg_t**)lf_allocate(
                1, sizeof(_networksender_0_0_msg_t*),
                &federate__s3_ns_federate__p3_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 1; i++) {
            federate__s3_ns_federate__p3_self[0]->_lf_msg[i] = &federate__s3_ns_federate__p3_self[0]->_lf_default__msg;
        }
        envs[federate__s3_main].startup_reactions[startup_reaction_count[federate__s3_main]++] = &federate__s3_ns_federate__p3_self[0]->_lf__reaction_0;
    
        federate__s3_ns_federate__p3_self[0]->_lf__reaction_0.deadline = NEVER;
        federate__s3_ns_federate__p3_self[0]->_lf__reaction_1.deadline = NEVER;
        federate__s3_ns_federate__p3_self[0]->_lf__reaction_2.deadline = NEVER;
        //***** End initializing federate__s3.ns_federate__p3
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3.ns_federate__p3_0 of class NetworkSender_1
        federate__s3_ns_federate__p3_0_self[0] = new__networksender_1_1();
        federate__s3_ns_federate__p3_0_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3_ns_federate__p3_0_self[0], NULL, trace_reactor, "ns_federate__p3_0");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        federate__s3_ns_federate__p3_0_self[0]->_lf_msg_width = 1;
        // Allocate memory for multiport inputs.
        federate__s3_ns_federate__p3_0_self[0]->_lf_msg = (_networksender_1_1_msg_t**)lf_allocate(
                1, sizeof(_networksender_1_1_msg_t*),
                &federate__s3_ns_federate__p3_0_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 1; i++) {
            federate__s3_ns_federate__p3_0_self[0]->_lf_msg[i] = &federate__s3_ns_federate__p3_0_self[0]->_lf_default__msg;
        }
        envs[federate__s3_main].startup_reactions[startup_reaction_count[federate__s3_main]++] = &federate__s3_ns_federate__p3_0_self[0]->_lf__reaction_0;
    
        federate__s3_ns_federate__p3_0_self[0]->_lf__reaction_0.deadline = NEVER;
        federate__s3_ns_federate__p3_0_self[0]->_lf__reaction_1.deadline = NEVER;
        federate__s3_ns_federate__p3_0_self[0]->_lf__reaction_2.deadline = NEVER;
        //***** End initializing federate__s3.ns_federate__p3_0
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3.ns_federate__p3_1 of class NetworkSender_2
        federate__s3_ns_federate__p3_1_self[0] = new__networksender_2_2();
        federate__s3_ns_federate__p3_1_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3_ns_federate__p3_1_self[0], NULL, trace_reactor, "ns_federate__p3_1");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        federate__s3_ns_federate__p3_1_self[0]->_lf_msg_width = 1;
        // Allocate memory for multiport inputs.
        federate__s3_ns_federate__p3_1_self[0]->_lf_msg = (_networksender_2_2_msg_t**)lf_allocate(
                1, sizeof(_networksender_2_2_msg_t*),
                &federate__s3_ns_federate__p3_1_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 1; i++) {
            federate__s3_ns_federate__p3_1_self[0]->_lf_msg[i] = &federate__s3_ns_federate__p3_1_self[0]->_lf_default__msg;
        }
        envs[federate__s3_main].startup_reactions[startup_reaction_count[federate__s3_main]++] = &federate__s3_ns_federate__p3_1_self[0]->_lf__reaction_0;
    
        federate__s3_ns_federate__p3_1_self[0]->_lf__reaction_0.deadline = NEVER;
        federate__s3_ns_federate__p3_1_self[0]->_lf__reaction_1.deadline = NEVER;
        federate__s3_ns_federate__p3_1_self[0]->_lf__reaction_2.deadline = NEVER;
        //***** End initializing federate__s3.ns_federate__p3_1
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3.ns_federate__p3_2 of class NetworkSender_3
        federate__s3_ns_federate__p3_2_self[0] = new__networksender_3_3();
        federate__s3_ns_federate__p3_2_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3_ns_federate__p3_2_self[0], NULL, trace_reactor, "ns_federate__p3_2");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        federate__s3_ns_federate__p3_2_self[0]->_lf_msg_width = 1;
        // Allocate memory for multiport inputs.
        federate__s3_ns_federate__p3_2_self[0]->_lf_msg = (_networksender_3_3_msg_t**)lf_allocate(
                1, sizeof(_networksender_3_3_msg_t*),
                &federate__s3_ns_federate__p3_2_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 1; i++) {
            federate__s3_ns_federate__p3_2_self[0]->_lf_msg[i] = &federate__s3_ns_federate__p3_2_self[0]->_lf_default__msg;
        }
        envs[federate__s3_main].startup_reactions[startup_reaction_count[federate__s3_main]++] = &federate__s3_ns_federate__p3_2_self[0]->_lf__reaction_0;
    
        federate__s3_ns_federate__p3_2_self[0]->_lf__reaction_0.deadline = NEVER;
        federate__s3_ns_federate__p3_2_self[0]->_lf__reaction_1.deadline = NEVER;
        federate__s3_ns_federate__p3_2_self[0]->_lf__reaction_2.deadline = NEVER;
        //***** End initializing federate__s3.ns_federate__p3_2
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3.ns_federate__plant_1 of class NetworkSender_4
        federate__s3_ns_federate__plant_1_self[0] = new__networksender_4_4();
        federate__s3_ns_federate__plant_1_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3_ns_federate__plant_1_self[0], NULL, trace_reactor, "ns_federate__plant_1");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        federate__s3_ns_federate__plant_1_self[0]->_lf_msg_width = 1;
        // Allocate memory for multiport inputs.
        federate__s3_ns_federate__plant_1_self[0]->_lf_msg = (_networksender_4_4_msg_t**)lf_allocate(
                1, sizeof(_networksender_4_4_msg_t*),
                &federate__s3_ns_federate__plant_1_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 1; i++) {
            federate__s3_ns_federate__plant_1_self[0]->_lf_msg[i] = &federate__s3_ns_federate__plant_1_self[0]->_lf_default__msg;
        }
        envs[federate__s3_main].startup_reactions[startup_reaction_count[federate__s3_main]++] = &federate__s3_ns_federate__plant_1_self[0]->_lf__reaction_0;
    
        federate__s3_ns_federate__plant_1_self[0]->_lf__reaction_0.deadline = NEVER;
        federate__s3_ns_federate__plant_1_self[0]->_lf__reaction_1.deadline = NEVER;
        federate__s3_ns_federate__plant_1_self[0]->_lf__reaction_2.deadline = NEVER;
        //***** End initializing federate__s3.ns_federate__plant_1
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3.ns_federate__p3_3 of class NetworkSender_5
        federate__s3_ns_federate__p3_3_self[0] = new__networksender_5_5();
        federate__s3_ns_federate__p3_3_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3_ns_federate__p3_3_self[0], NULL, trace_reactor, "ns_federate__p3_3");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        federate__s3_ns_federate__p3_3_self[0]->_lf_msg_width = 1;
        // Allocate memory for multiport inputs.
        federate__s3_ns_federate__p3_3_self[0]->_lf_msg = (_networksender_5_5_msg_t**)lf_allocate(
                1, sizeof(_networksender_5_5_msg_t*),
                &federate__s3_ns_federate__p3_3_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 1; i++) {
            federate__s3_ns_federate__p3_3_self[0]->_lf_msg[i] = &federate__s3_ns_federate__p3_3_self[0]->_lf_default__msg;
        }
        envs[federate__s3_main].startup_reactions[startup_reaction_count[federate__s3_main]++] = &federate__s3_ns_federate__p3_3_self[0]->_lf__reaction_0;
    
        federate__s3_ns_federate__p3_3_self[0]->_lf__reaction_0.deadline = NEVER;
        federate__s3_ns_federate__p3_3_self[0]->_lf__reaction_1.deadline = NEVER;
        federate__s3_ns_federate__p3_3_self[0]->_lf__reaction_2.deadline = NEVER;
        //***** End initializing federate__s3.ns_federate__p3_3
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3.nr_federate__s3 of class NetworkReceiver_148
        federate__s3_nr_federate__s3_self[0] = new__networkreceiver_148();
        federate__s3_nr_federate__s3_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3_nr_federate__s3_self[0], NULL, trace_reactor, "nr_federate__s3");
        _lf_register_trace_event(federate__s3_nr_federate__s3_self[0], &(federate__s3_nr_federate__s3_self[0]->_lf__networkMessage), trace_trigger, "nr_federate__s3.networkMessage");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        // width of -2 indicates that it is not a multiport.
        federate__s3_nr_federate__s3_self[0]->_lf_msg_width = -2;
        // Initializing action federate__s3.nr_federate__s3.networkMessage
        federate__s3_nr_federate__s3_self[0]->_lf__networkMessage.offset = 0;
        federate__s3_nr_federate__s3_self[0]->_lf__networkMessage.period = -1;
        federate__s3_nr_federate__s3_self[0]->_lf__networkMessage.last_tag = NEVER_TAG;
        federate__s3_nr_federate__s3_self[0]->_lf__networkMessage.mode = NULL;
        _lf_initialize_template((token_template_t*)
                &(federate__s3_nr_federate__s3_self[0]->_lf__networkMessage),
        sizeof(double));
        federate__s3_nr_federate__s3_self[0]->_lf__networkMessage.status = absent;
        federate__s3_nr_federate__s3_self[0]->_lf__reaction_0.deadline = NEVER;
        //***** End initializing federate__s3.nr_federate__s3
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3.nr_federate__s3_0 of class NetworkReceiver_149
        federate__s3_nr_federate__s3_0_self[0] = new__networkreceiver_149();
        federate__s3_nr_federate__s3_0_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3_nr_federate__s3_0_self[0], NULL, trace_reactor, "nr_federate__s3_0");
        _lf_register_trace_event(federate__s3_nr_federate__s3_0_self[0], &(federate__s3_nr_federate__s3_0_self[0]->_lf__networkMessage), trace_trigger, "nr_federate__s3_0.networkMessage");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        // width of -2 indicates that it is not a multiport.
        federate__s3_nr_federate__s3_0_self[0]->_lf_msg_width = -2;
        // Initializing action federate__s3.nr_federate__s3_0.networkMessage
        federate__s3_nr_federate__s3_0_self[0]->_lf__networkMessage.offset = 0;
        federate__s3_nr_federate__s3_0_self[0]->_lf__networkMessage.period = -1;
        federate__s3_nr_federate__s3_0_self[0]->_lf__networkMessage.last_tag = NEVER_TAG;
        federate__s3_nr_federate__s3_0_self[0]->_lf__networkMessage.mode = NULL;
        _lf_initialize_template((token_template_t*)
                &(federate__s3_nr_federate__s3_0_self[0]->_lf__networkMessage),
        sizeof(double));
        federate__s3_nr_federate__s3_0_self[0]->_lf__networkMessage.status = absent;
        federate__s3_nr_federate__s3_0_self[0]->_lf__reaction_0.deadline = NEVER;
        //***** End initializing federate__s3.nr_federate__s3_0
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3.nr_federate__s3_1 of class NetworkReceiver_150
        federate__s3_nr_federate__s3_1_self[0] = new__networkreceiver_150();
        federate__s3_nr_federate__s3_1_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3_nr_federate__s3_1_self[0], NULL, trace_reactor, "nr_federate__s3_1");
        _lf_register_trace_event(federate__s3_nr_federate__s3_1_self[0], &(federate__s3_nr_federate__s3_1_self[0]->_lf__networkMessage), trace_trigger, "nr_federate__s3_1.networkMessage");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        // width of -2 indicates that it is not a multiport.
        federate__s3_nr_federate__s3_1_self[0]->_lf_msg_width = -2;
        // Initializing action federate__s3.nr_federate__s3_1.networkMessage
        federate__s3_nr_federate__s3_1_self[0]->_lf__networkMessage.offset = 0;
        federate__s3_nr_federate__s3_1_self[0]->_lf__networkMessage.period = -1;
        federate__s3_nr_federate__s3_1_self[0]->_lf__networkMessage.last_tag = NEVER_TAG;
        federate__s3_nr_federate__s3_1_self[0]->_lf__networkMessage.mode = NULL;
        _lf_initialize_template((token_template_t*)
                &(federate__s3_nr_federate__s3_1_self[0]->_lf__networkMessage),
        sizeof(double));
        federate__s3_nr_federate__s3_1_self[0]->_lf__networkMessage.status = absent;
        federate__s3_nr_federate__s3_1_self[0]->_lf__reaction_0.deadline = NEVER;
        //***** End initializing federate__s3.nr_federate__s3_1
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3.nr_federate__s3_2 of class NetworkReceiver_151
        federate__s3_nr_federate__s3_2_self[0] = new__networkreceiver_151();
        federate__s3_nr_federate__s3_2_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3_nr_federate__s3_2_self[0], NULL, trace_reactor, "nr_federate__s3_2");
        _lf_register_trace_event(federate__s3_nr_federate__s3_2_self[0], &(federate__s3_nr_federate__s3_2_self[0]->_lf__networkMessage), trace_trigger, "nr_federate__s3_2.networkMessage");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        // width of -2 indicates that it is not a multiport.
        federate__s3_nr_federate__s3_2_self[0]->_lf_msg_width = -2;
        // Initializing action federate__s3.nr_federate__s3_2.networkMessage
        federate__s3_nr_federate__s3_2_self[0]->_lf__networkMessage.offset = 0;
        federate__s3_nr_federate__s3_2_self[0]->_lf__networkMessage.period = -1;
        federate__s3_nr_federate__s3_2_self[0]->_lf__networkMessage.last_tag = NEVER_TAG;
        federate__s3_nr_federate__s3_2_self[0]->_lf__networkMessage.mode = NULL;
        _lf_initialize_template((token_template_t*)
                &(federate__s3_nr_federate__s3_2_self[0]->_lf__networkMessage),
        sizeof(double));
        federate__s3_nr_federate__s3_2_self[0]->_lf__networkMessage.status = absent;
        federate__s3_nr_federate__s3_2_self[0]->_lf__reaction_0.deadline = NEVER;
        //***** End initializing federate__s3.nr_federate__s3_2
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3._s3AP_in0 of class _s3AP_in
        federate__s3__s3ap_in0_self[0] = new___s3ap_in();
        federate__s3__s3ap_in0_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3__s3ap_in0_self[0], NULL, trace_reactor, "_s3AP_in0");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        federate__s3__s3ap_in0_self[0]->_lf_port_width = 1;
        // Allocate memory for multiport output.
        federate__s3__s3ap_in0_self[0]->_lf_port = (__s3ap_in_port_t*)lf_allocate(
                1, sizeof(__s3ap_in_port_t),
                &federate__s3__s3ap_in0_self[0]->base.allocations); 
        federate__s3__s3ap_in0_self[0]->_lf_port_pointers = (__s3ap_in_port_t**)lf_allocate(
                1, sizeof(__s3ap_in_port_t*),
                &federate__s3__s3ap_in0_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 1; i++) {
                federate__s3__s3ap_in0_self[0]->_lf_port_pointers[i] = &(federate__s3__s3ap_in0_self[0]->_lf_port[i]);
        }
        // width of -2 indicates that it is not a multiport.
        federate__s3__s3ap_in0_self[0]->_lf_port0_width = -2;
    
        //***** End initializing federate__s3._s3AP_in0
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3._s3AV_in0 of class _s3AV_in
        federate__s3__s3av_in0_self[0] = new___s3av_in();
        federate__s3__s3av_in0_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3__s3av_in0_self[0], NULL, trace_reactor, "_s3AV_in0");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        federate__s3__s3av_in0_self[0]->_lf_port_width = 1;
        // Allocate memory for multiport output.
        federate__s3__s3av_in0_self[0]->_lf_port = (__s3av_in_port_t*)lf_allocate(
                1, sizeof(__s3av_in_port_t),
                &federate__s3__s3av_in0_self[0]->base.allocations); 
        federate__s3__s3av_in0_self[0]->_lf_port_pointers = (__s3av_in_port_t**)lf_allocate(
                1, sizeof(__s3av_in_port_t*),
                &federate__s3__s3av_in0_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 1; i++) {
                federate__s3__s3av_in0_self[0]->_lf_port_pointers[i] = &(federate__s3__s3av_in0_self[0]->_lf_port[i]);
        }
        // width of -2 indicates that it is not a multiport.
        federate__s3__s3av_in0_self[0]->_lf_port0_width = -2;
    
        //***** End initializing federate__s3._s3AV_in0
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3._s3CP_in0 of class _s3CP_in
        federate__s3__s3cp_in0_self[0] = new___s3cp_in();
        federate__s3__s3cp_in0_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3__s3cp_in0_self[0], NULL, trace_reactor, "_s3CP_in0");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        federate__s3__s3cp_in0_self[0]->_lf_port_width = 1;
        // Allocate memory for multiport output.
        federate__s3__s3cp_in0_self[0]->_lf_port = (__s3cp_in_port_t*)lf_allocate(
                1, sizeof(__s3cp_in_port_t),
                &federate__s3__s3cp_in0_self[0]->base.allocations); 
        federate__s3__s3cp_in0_self[0]->_lf_port_pointers = (__s3cp_in_port_t**)lf_allocate(
                1, sizeof(__s3cp_in_port_t*),
                &federate__s3__s3cp_in0_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 1; i++) {
                federate__s3__s3cp_in0_self[0]->_lf_port_pointers[i] = &(federate__s3__s3cp_in0_self[0]->_lf_port[i]);
        }
        // width of -2 indicates that it is not a multiport.
        federate__s3__s3cp_in0_self[0]->_lf_port0_width = -2;
    
        //***** End initializing federate__s3._s3CP_in0
    }
    {
        _federate__s3_main_main_self_t *self = federate__s3_main_self[0];
        // ***** Start initializing federate__s3._s3CV_in0 of class _s3CV_in
        federate__s3__s3cv_in0_self[0] = new___s3cv_in();
        federate__s3__s3cv_in0_self[0]->base.environment = &envs[federate__s3_main];
        _lf_register_trace_event(federate__s3__s3cv_in0_self[0], NULL, trace_reactor, "_s3CV_in0");
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        federate__s3__s3cv_in0_self[0]->_lf_port_width = 1;
        // Allocate memory for multiport output.
        federate__s3__s3cv_in0_self[0]->_lf_port = (__s3cv_in_port_t*)lf_allocate(
                1, sizeof(__s3cv_in_port_t),
                &federate__s3__s3cv_in0_self[0]->base.allocations); 
        federate__s3__s3cv_in0_self[0]->_lf_port_pointers = (__s3cv_in_port_t**)lf_allocate(
                1, sizeof(__s3cv_in_port_t*),
                &federate__s3__s3cv_in0_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 1; i++) {
                federate__s3__s3cv_in0_self[0]->_lf_port_pointers[i] = &(federate__s3__s3cv_in0_self[0]->_lf_port[i]);
        }
        // width of -2 indicates that it is not a multiport.
        federate__s3__s3cv_in0_self[0]->_lf_port0_width = -2;
    
        //***** End initializing federate__s3._s3CV_in0
    }
    //***** End initializing federate__s3
    // **** Start deferred initialize for federate__s3
    {
        federate__s3_main_self[0]->base.name = "federate__s3";
        federate__s3_main_self[0]->base.parent = (self_base_t*)NULL;
    
    
    
        // **** Start deferred initialize for federate__s3.s3
        {
            federate__s3_s3_self[0]->base.name = "s3";
            federate__s3_s3_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of federate__s3.s3.
            federate__s3_s3_self[0]->_lf__reaction_0.num_outputs = 2;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            federate__s3_s3_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                    2, sizeof(trigger_t**),
                    &federate__s3_s3_self[0]->base.allocations);
            federate__s3_s3_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                    2, sizeof(int),
                    &federate__s3_s3_self[0]->base.allocations);
            federate__s3_s3_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                    2, sizeof(bool*),
                    &federate__s3_s3_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    federate__s3_s3_self[0]->_lf__reaction_0.output_produced[count++] = &federate__s3_s3_self[0]->_lf_request.is_present;
                }
                {
                    federate__s3_s3_self[0]->_lf__reaction_0.output_produced[count++] = &federate__s3_s3_self[0]->_lf_sim_start_time.is_present;
                }
            }
            
            // ** End initialization for reaction 0 of federate__s3.s3
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of federate__s3.s3.
            federate__s3_s3_self[0]->_lf__reaction_1.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            federate__s3_s3_self[0]->_lf__reaction_1.triggers = (trigger_t***)lf_allocate(
                    1, sizeof(trigger_t**),
                    &federate__s3_s3_self[0]->base.allocations);
            federate__s3_s3_self[0]->_lf__reaction_1.triggered_sizes = (int*)lf_allocate(
                    1, sizeof(int),
                    &federate__s3_s3_self[0]->base.allocations);
            federate__s3_s3_self[0]->_lf__reaction_1.output_produced = (bool**)lf_allocate(
                    1, sizeof(bool*),
                    &federate__s3_s3_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    federate__s3_s3_self[0]->_lf__reaction_1.output_produced[count++] = &federate__s3_s3_self[0]->_lf_AP_out.is_present;
                }
            }
            
            // ** End initialization for reaction 1 of federate__s3.s3
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of federate__s3.s3.
            federate__s3_s3_self[0]->_lf__reaction_2.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            federate__s3_s3_self[0]->_lf__reaction_2.triggers = (trigger_t***)lf_allocate(
                    1, sizeof(trigger_t**),
                    &federate__s3_s3_self[0]->base.allocations);
            federate__s3_s3_self[0]->_lf__reaction_2.triggered_sizes = (int*)lf_allocate(
                    1, sizeof(int),
                    &federate__s3_s3_self[0]->base.allocations);
            federate__s3_s3_self[0]->_lf__reaction_2.output_produced = (bool**)lf_allocate(
                    1, sizeof(bool*),
                    &federate__s3_s3_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    federate__s3_s3_self[0]->_lf__reaction_2.output_produced[count++] = &federate__s3_s3_self[0]->_lf_AV_out.is_present;
                }
            }
            
            // ** End initialization for reaction 2 of federate__s3.s3
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_4 of federate__s3.s3.
            federate__s3_s3_self[0]->_lf__reaction_3.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            federate__s3_s3_self[0]->_lf__reaction_3.triggers = (trigger_t***)lf_allocate(
                    1, sizeof(trigger_t**),
                    &federate__s3_s3_self[0]->base.allocations);
            federate__s3_s3_self[0]->_lf__reaction_3.triggered_sizes = (int*)lf_allocate(
                    1, sizeof(int),
                    &federate__s3_s3_self[0]->base.allocations);
            federate__s3_s3_self[0]->_lf__reaction_3.output_produced = (bool**)lf_allocate(
                    1, sizeof(bool*),
                    &federate__s3_s3_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    federate__s3_s3_self[0]->_lf__reaction_3.output_produced[count++] = &federate__s3_s3_self[0]->_lf_CP_out.is_present;
                }
            }
            
            // ** End initialization for reaction 3 of federate__s3.s3
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_5 of federate__s3.s3.
            federate__s3_s3_self[0]->_lf__reaction_4.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            federate__s3_s3_self[0]->_lf__reaction_4.triggers = (trigger_t***)lf_allocate(
                    1, sizeof(trigger_t**),
                    &federate__s3_s3_self[0]->base.allocations);
            federate__s3_s3_self[0]->_lf__reaction_4.triggered_sizes = (int*)lf_allocate(
                    1, sizeof(int),
                    &federate__s3_s3_self[0]->base.allocations);
            federate__s3_s3_self[0]->_lf__reaction_4.output_produced = (bool**)lf_allocate(
                    1, sizeof(bool*),
                    &federate__s3_s3_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    federate__s3_s3_self[0]->_lf__reaction_4.output_produced[count++] = &federate__s3_s3_self[0]->_lf_CV_out.is_present;
                }
            }
            
            // ** End initialization for reaction 4 of federate__s3.s3
        
        }
        // **** End of deferred initialize for federate__s3.s3
        // **** Start deferred initialize for federate__s3.ns_federate__p3
        {
            federate__s3_ns_federate__p3_self[0]->base.name = "ns_federate__p3";
            federate__s3_ns_federate__p3_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of federate__s3.ns_federate__p3.
            federate__s3_ns_federate__p3_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of federate__s3.ns_federate__p3
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of federate__s3.ns_federate__p3.
            federate__s3_ns_federate__p3_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 1 of federate__s3.ns_federate__p3
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of federate__s3.ns_federate__p3.
            federate__s3_ns_federate__p3_self[0]->_lf__reaction_2.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 2 of federate__s3.ns_federate__p3
        
        }
        // **** End of deferred initialize for federate__s3.ns_federate__p3
        // **** Start deferred initialize for federate__s3.ns_federate__p3_0
        {
            federate__s3_ns_federate__p3_0_self[0]->base.name = "ns_federate__p3_0";
            federate__s3_ns_federate__p3_0_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of federate__s3.ns_federate__p3_0.
            federate__s3_ns_federate__p3_0_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of federate__s3.ns_federate__p3_0
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of federate__s3.ns_federate__p3_0.
            federate__s3_ns_federate__p3_0_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 1 of federate__s3.ns_federate__p3_0
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of federate__s3.ns_federate__p3_0.
            federate__s3_ns_federate__p3_0_self[0]->_lf__reaction_2.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 2 of federate__s3.ns_federate__p3_0
        
        }
        // **** End of deferred initialize for federate__s3.ns_federate__p3_0
        // **** Start deferred initialize for federate__s3.ns_federate__p3_1
        {
            federate__s3_ns_federate__p3_1_self[0]->base.name = "ns_federate__p3_1";
            federate__s3_ns_federate__p3_1_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of federate__s3.ns_federate__p3_1.
            federate__s3_ns_federate__p3_1_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of federate__s3.ns_federate__p3_1
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of federate__s3.ns_federate__p3_1.
            federate__s3_ns_federate__p3_1_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 1 of federate__s3.ns_federate__p3_1
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of federate__s3.ns_federate__p3_1.
            federate__s3_ns_federate__p3_1_self[0]->_lf__reaction_2.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 2 of federate__s3.ns_federate__p3_1
        
        }
        // **** End of deferred initialize for federate__s3.ns_federate__p3_1
        // **** Start deferred initialize for federate__s3.ns_federate__p3_2
        {
            federate__s3_ns_federate__p3_2_self[0]->base.name = "ns_federate__p3_2";
            federate__s3_ns_federate__p3_2_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of federate__s3.ns_federate__p3_2.
            federate__s3_ns_federate__p3_2_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of federate__s3.ns_federate__p3_2
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of federate__s3.ns_federate__p3_2.
            federate__s3_ns_federate__p3_2_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 1 of federate__s3.ns_federate__p3_2
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of federate__s3.ns_federate__p3_2.
            federate__s3_ns_federate__p3_2_self[0]->_lf__reaction_2.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 2 of federate__s3.ns_federate__p3_2
        
        }
        // **** End of deferred initialize for federate__s3.ns_federate__p3_2
        // **** Start deferred initialize for federate__s3.ns_federate__plant_1
        {
            federate__s3_ns_federate__plant_1_self[0]->base.name = "ns_federate__plant_1";
            federate__s3_ns_federate__plant_1_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of federate__s3.ns_federate__plant_1.
            federate__s3_ns_federate__plant_1_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of federate__s3.ns_federate__plant_1
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of federate__s3.ns_federate__plant_1.
            federate__s3_ns_federate__plant_1_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 1 of federate__s3.ns_federate__plant_1
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of federate__s3.ns_federate__plant_1.
            federate__s3_ns_federate__plant_1_self[0]->_lf__reaction_2.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 2 of federate__s3.ns_federate__plant_1
        
        }
        // **** End of deferred initialize for federate__s3.ns_federate__plant_1
        // **** Start deferred initialize for federate__s3.ns_federate__p3_3
        {
            federate__s3_ns_federate__p3_3_self[0]->base.name = "ns_federate__p3_3";
            federate__s3_ns_federate__p3_3_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of federate__s3.ns_federate__p3_3.
            federate__s3_ns_federate__p3_3_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of federate__s3.ns_federate__p3_3
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of federate__s3.ns_federate__p3_3.
            federate__s3_ns_federate__p3_3_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 1 of federate__s3.ns_federate__p3_3
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of federate__s3.ns_federate__p3_3.
            federate__s3_ns_federate__p3_3_self[0]->_lf__reaction_2.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 2 of federate__s3.ns_federate__p3_3
        
        }
        // **** End of deferred initialize for federate__s3.ns_federate__p3_3
        // **** Start deferred initialize for federate__s3.nr_federate__s3
        {
            federate__s3_nr_federate__s3_self[0]->base.name = "nr_federate__s3";
            federate__s3_nr_federate__s3_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of federate__s3.nr_federate__s3.
            federate__s3_nr_federate__s3_self[0]->_lf__reaction_0.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            federate__s3_nr_federate__s3_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                    1, sizeof(trigger_t**),
                    &federate__s3_nr_federate__s3_self[0]->base.allocations);
            federate__s3_nr_federate__s3_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                    1, sizeof(int),
                    &federate__s3_nr_federate__s3_self[0]->base.allocations);
            federate__s3_nr_federate__s3_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                    1, sizeof(bool*),
                    &federate__s3_nr_federate__s3_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    federate__s3_nr_federate__s3_self[0]->_lf__reaction_0.output_produced[count++] = &federate__s3_nr_federate__s3_self[0]->_lf_msg.is_present;
                }
            }
            
            // ** End initialization for reaction 0 of federate__s3.nr_federate__s3
        
        }
        // **** End of deferred initialize for federate__s3.nr_federate__s3
        // **** Start deferred initialize for federate__s3.nr_federate__s3_0
        {
            federate__s3_nr_federate__s3_0_self[0]->base.name = "nr_federate__s3_0";
            federate__s3_nr_federate__s3_0_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of federate__s3.nr_federate__s3_0.
            federate__s3_nr_federate__s3_0_self[0]->_lf__reaction_0.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            federate__s3_nr_federate__s3_0_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                    1, sizeof(trigger_t**),
                    &federate__s3_nr_federate__s3_0_self[0]->base.allocations);
            federate__s3_nr_federate__s3_0_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                    1, sizeof(int),
                    &federate__s3_nr_federate__s3_0_self[0]->base.allocations);
            federate__s3_nr_federate__s3_0_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                    1, sizeof(bool*),
                    &federate__s3_nr_federate__s3_0_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    federate__s3_nr_federate__s3_0_self[0]->_lf__reaction_0.output_produced[count++] = &federate__s3_nr_federate__s3_0_self[0]->_lf_msg.is_present;
                }
            }
            
            // ** End initialization for reaction 0 of federate__s3.nr_federate__s3_0
        
        }
        // **** End of deferred initialize for federate__s3.nr_federate__s3_0
        // **** Start deferred initialize for federate__s3.nr_federate__s3_1
        {
            federate__s3_nr_federate__s3_1_self[0]->base.name = "nr_federate__s3_1";
            federate__s3_nr_federate__s3_1_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of federate__s3.nr_federate__s3_1.
            federate__s3_nr_federate__s3_1_self[0]->_lf__reaction_0.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            federate__s3_nr_federate__s3_1_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                    1, sizeof(trigger_t**),
                    &federate__s3_nr_federate__s3_1_self[0]->base.allocations);
            federate__s3_nr_federate__s3_1_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                    1, sizeof(int),
                    &federate__s3_nr_federate__s3_1_self[0]->base.allocations);
            federate__s3_nr_federate__s3_1_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                    1, sizeof(bool*),
                    &federate__s3_nr_federate__s3_1_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    federate__s3_nr_federate__s3_1_self[0]->_lf__reaction_0.output_produced[count++] = &federate__s3_nr_federate__s3_1_self[0]->_lf_msg.is_present;
                }
            }
            
            // ** End initialization for reaction 0 of federate__s3.nr_federate__s3_1
        
        }
        // **** End of deferred initialize for federate__s3.nr_federate__s3_1
        // **** Start deferred initialize for federate__s3.nr_federate__s3_2
        {
            federate__s3_nr_federate__s3_2_self[0]->base.name = "nr_federate__s3_2";
            federate__s3_nr_federate__s3_2_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of federate__s3.nr_federate__s3_2.
            federate__s3_nr_federate__s3_2_self[0]->_lf__reaction_0.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            federate__s3_nr_federate__s3_2_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                    1, sizeof(trigger_t**),
                    &federate__s3_nr_federate__s3_2_self[0]->base.allocations);
            federate__s3_nr_federate__s3_2_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                    1, sizeof(int),
                    &federate__s3_nr_federate__s3_2_self[0]->base.allocations);
            federate__s3_nr_federate__s3_2_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                    1, sizeof(bool*),
                    &federate__s3_nr_federate__s3_2_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    federate__s3_nr_federate__s3_2_self[0]->_lf__reaction_0.output_produced[count++] = &federate__s3_nr_federate__s3_2_self[0]->_lf_msg.is_present;
                }
            }
            
            // ** End initialization for reaction 0 of federate__s3.nr_federate__s3_2
        
        }
        // **** End of deferred initialize for federate__s3.nr_federate__s3_2
        // **** Start deferred initialize for federate__s3._s3AP_in0
        {
            federate__s3__s3ap_in0_self[0]->base.name = "_s3AP_in0";
            federate__s3__s3ap_in0_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
        
        
        }
        // **** End of deferred initialize for federate__s3._s3AP_in0
        // **** Start deferred initialize for federate__s3._s3AV_in0
        {
            federate__s3__s3av_in0_self[0]->base.name = "_s3AV_in0";
            federate__s3__s3av_in0_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
        
        
        }
        // **** End of deferred initialize for federate__s3._s3AV_in0
        // **** Start deferred initialize for federate__s3._s3CP_in0
        {
            federate__s3__s3cp_in0_self[0]->base.name = "_s3CP_in0";
            federate__s3__s3cp_in0_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
        
        
        }
        // **** End of deferred initialize for federate__s3._s3CP_in0
        // **** Start deferred initialize for federate__s3._s3CV_in0
        {
            federate__s3__s3cv_in0_self[0]->base.name = "_s3CV_in0";
            federate__s3__s3cv_in0_self[0]->base.parent = (self_base_t*)federate__s3_main_self[0];
        
        
        
        }
        // **** End of deferred initialize for federate__s3._s3CV_in0
    }
    // **** End of deferred initialize for federate__s3
    // **** Start non-nested deferred initialize for federate__s3
    {
    
    
    
        // **** Start non-nested deferred initialize for federate__s3.s3
        {
        
            // For reference counting, set num_destinations for port federate__s3.s3.AP_out.
            // Iterate over range federate__s3.s3.AP_out(0,1)->[federate__s3.ns_federate__p3.msg(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3_s3_self[src_runtime]->_lf_AP_out._base.num_destinations = 1;
                federate__s3_s3_self[src_runtime]->_lf_AP_out._base.source_reactor = (self_base_t*)federate__s3_s3_self[src_runtime];
            }
            // For reference counting, set num_destinations for port federate__s3.s3.AV_out.
            // Iterate over range federate__s3.s3.AV_out(0,1)->[federate__s3.ns_federate__p3_0.msg(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3_s3_self[src_runtime]->_lf_AV_out._base.num_destinations = 1;
                federate__s3_s3_self[src_runtime]->_lf_AV_out._base.source_reactor = (self_base_t*)federate__s3_s3_self[src_runtime];
            }
            // For reference counting, set num_destinations for port federate__s3.s3.CP_out.
            // Iterate over range federate__s3.s3.CP_out(0,1)->[federate__s3.ns_federate__p3_1.msg(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3_s3_self[src_runtime]->_lf_CP_out._base.num_destinations = 1;
                federate__s3_s3_self[src_runtime]->_lf_CP_out._base.source_reactor = (self_base_t*)federate__s3_s3_self[src_runtime];
            }
            // For reference counting, set num_destinations for port federate__s3.s3.CV_out.
            // Iterate over range federate__s3.s3.CV_out(0,1)->[federate__s3.ns_federate__p3_2.msg(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3_s3_self[src_runtime]->_lf_CV_out._base.num_destinations = 1;
                federate__s3_s3_self[src_runtime]->_lf_CV_out._base.source_reactor = (self_base_t*)federate__s3_s3_self[src_runtime];
            }
            // For reference counting, set num_destinations for port federate__s3.s3.request.
            // Iterate over range federate__s3.s3.request(0,1)->[federate__s3.ns_federate__plant_1.msg(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3_s3_self[src_runtime]->_lf_request._base.num_destinations = 1;
                federate__s3_s3_self[src_runtime]->_lf_request._base.source_reactor = (self_base_t*)federate__s3_s3_self[src_runtime];
            }
            // For reference counting, set num_destinations for port federate__s3.s3.sim_start_time.
            // Iterate over range federate__s3.s3.sim_start_time(0,1)->[federate__s3.ns_federate__p3_3.msg(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3_s3_self[src_runtime]->_lf_sim_start_time._base.num_destinations = 1;
                federate__s3_s3_self[src_runtime]->_lf_sim_start_time._base.source_reactor = (self_base_t*)federate__s3_s3_self[src_runtime];
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range federate__s3.s3.request(0,1)->[federate__s3.ns_federate__plant_1.msg(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 0 of federate__s3.s3 triggers 1 downstream reactions
                    // through port federate__s3.s3.request.
                    federate__s3_s3_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 0 of federate__s3.s3, allocate an
                    // array of trigger pointers for downstream reactions through port federate__s3.s3.request
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &federate__s3_s3_self[src_runtime]->base.allocations); 
                    federate__s3_s3_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range federate__s3.s3.sim_start_time(0,1)->[federate__s3.ns_federate__p3_3.msg(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 0 of federate__s3.s3 triggers 1 downstream reactions
                    // through port federate__s3.s3.sim_start_time.
                    federate__s3_s3_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 0 of federate__s3.s3, allocate an
                    // array of trigger pointers for downstream reactions through port federate__s3.s3.sim_start_time
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &federate__s3_s3_self[src_runtime]->base.allocations); 
                    federate__s3_s3_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges federate__s3.s3.request(0,1)->[federate__s3.ns_federate__plant_1.msg(0,1)] and federate__s3.ns_federate__plant_1.msg(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range federate__s3.ns_federate__plant_1.msg(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port federate__s3.ns_federate__plant_1.msg's trigger struct.
                        federate__s3_s3_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &federate__s3_ns_federate__plant_1_self[dst_runtime]->_lf__msg;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 1;
                // Iterate over ranges federate__s3.s3.sim_start_time(0,1)->[federate__s3.ns_federate__p3_3.msg(0,1)] and federate__s3.ns_federate__p3_3.msg(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range federate__s3.ns_federate__p3_3.msg(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port federate__s3.ns_federate__p3_3.msg's trigger struct.
                        federate__s3_s3_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &federate__s3_ns_federate__p3_3_self[dst_runtime]->_lf__msg;
                    }
                }
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range federate__s3.s3.AP_out(0,1)->[federate__s3.ns_federate__p3.msg(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 1 of federate__s3.s3 triggers 1 downstream reactions
                    // through port federate__s3.s3.AP_out.
                    federate__s3_s3_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 1 of federate__s3.s3, allocate an
                    // array of trigger pointers for downstream reactions through port federate__s3.s3.AP_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &federate__s3_s3_self[src_runtime]->base.allocations); 
                    federate__s3_s3_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges federate__s3.s3.AP_out(0,1)->[federate__s3.ns_federate__p3.msg(0,1)] and federate__s3.ns_federate__p3.msg(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range federate__s3.ns_federate__p3.msg(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port federate__s3.ns_federate__p3.msg's trigger struct.
                        federate__s3_s3_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &federate__s3_ns_federate__p3_self[dst_runtime]->_lf__msg;
                    }
                }
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range federate__s3.s3.AV_out(0,1)->[federate__s3.ns_federate__p3_0.msg(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of federate__s3.s3 triggers 1 downstream reactions
                    // through port federate__s3.s3.AV_out.
                    federate__s3_s3_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of federate__s3.s3, allocate an
                    // array of trigger pointers for downstream reactions through port federate__s3.s3.AV_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &federate__s3_s3_self[src_runtime]->base.allocations); 
                    federate__s3_s3_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges federate__s3.s3.AV_out(0,1)->[federate__s3.ns_federate__p3_0.msg(0,1)] and federate__s3.ns_federate__p3_0.msg(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range federate__s3.ns_federate__p3_0.msg(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port federate__s3.ns_federate__p3_0.msg's trigger struct.
                        federate__s3_s3_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &federate__s3_ns_federate__p3_0_self[dst_runtime]->_lf__msg;
                    }
                }
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range federate__s3.s3.CP_out(0,1)->[federate__s3.ns_federate__p3_1.msg(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 3 of federate__s3.s3 triggers 1 downstream reactions
                    // through port federate__s3.s3.CP_out.
                    federate__s3_s3_self[src_runtime]->_lf__reaction_3.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 3 of federate__s3.s3, allocate an
                    // array of trigger pointers for downstream reactions through port federate__s3.s3.CP_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &federate__s3_s3_self[src_runtime]->base.allocations); 
                    federate__s3_s3_self[src_runtime]->_lf__reaction_3.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges federate__s3.s3.CP_out(0,1)->[federate__s3.ns_federate__p3_1.msg(0,1)] and federate__s3.ns_federate__p3_1.msg(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range federate__s3.ns_federate__p3_1.msg(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port federate__s3.ns_federate__p3_1.msg's trigger struct.
                        federate__s3_s3_self[src_runtime]->_lf__reaction_3.triggers[triggers_index[src_runtime] + src_channel][0] = &federate__s3_ns_federate__p3_1_self[dst_runtime]->_lf__msg;
                    }
                }
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range federate__s3.s3.CV_out(0,1)->[federate__s3.ns_federate__p3_2.msg(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 4 of federate__s3.s3 triggers 1 downstream reactions
                    // through port federate__s3.s3.CV_out.
                    federate__s3_s3_self[src_runtime]->_lf__reaction_4.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 4 of federate__s3.s3, allocate an
                    // array of trigger pointers for downstream reactions through port federate__s3.s3.CV_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &federate__s3_s3_self[src_runtime]->base.allocations); 
                    federate__s3_s3_self[src_runtime]->_lf__reaction_4.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges federate__s3.s3.CV_out(0,1)->[federate__s3.ns_federate__p3_2.msg(0,1)] and federate__s3.ns_federate__p3_2.msg(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range federate__s3.ns_federate__p3_2.msg(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port federate__s3.ns_federate__p3_2.msg's trigger struct.
                        federate__s3_s3_self[src_runtime]->_lf__reaction_4.triggers[triggers_index[src_runtime] + src_channel][0] = &federate__s3_ns_federate__p3_2_self[dst_runtime]->_lf__msg;
                    }
                }
            }
        
        }
        // **** End of non-nested deferred initialize for federate__s3.s3
        // **** Start non-nested deferred initialize for federate__s3.ns_federate__p3
        {
        
        
        
        
        }
        // **** End of non-nested deferred initialize for federate__s3.ns_federate__p3
        // **** Start non-nested deferred initialize for federate__s3.ns_federate__p3_0
        {
        
        
        
        
        }
        // **** End of non-nested deferred initialize for federate__s3.ns_federate__p3_0
        // **** Start non-nested deferred initialize for federate__s3.ns_federate__p3_1
        {
        
        
        
        
        }
        // **** End of non-nested deferred initialize for federate__s3.ns_federate__p3_1
        // **** Start non-nested deferred initialize for federate__s3.ns_federate__p3_2
        {
        
        
        
        
        }
        // **** End of non-nested deferred initialize for federate__s3.ns_federate__p3_2
        // **** Start non-nested deferred initialize for federate__s3.ns_federate__plant_1
        {
        
        
        
        
        }
        // **** End of non-nested deferred initialize for federate__s3.ns_federate__plant_1
        // **** Start non-nested deferred initialize for federate__s3.ns_federate__p3_3
        {
        
        
        
        
        }
        // **** End of non-nested deferred initialize for federate__s3.ns_federate__p3_3
        // **** Start non-nested deferred initialize for federate__s3.nr_federate__s3
        {
        
            // For reference counting, set num_destinations for port federate__s3.nr_federate__s3.msg.
            // Iterate over range federate__s3.nr_federate__s3.msg(0,1)->[federate__s3.s3.AP_in(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3_nr_federate__s3_self[src_runtime]->_lf_msg._base.num_destinations = 1;
                federate__s3_nr_federate__s3_self[src_runtime]->_lf_msg._base.source_reactor = (self_base_t*)federate__s3_nr_federate__s3_self[src_runtime];
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range federate__s3.nr_federate__s3.msg(0,1)->[federate__s3.s3.AP_in(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 0 of federate__s3.nr_federate__s3 triggers 1 downstream reactions
                    // through port federate__s3.nr_federate__s3.msg.
                    federate__s3_nr_federate__s3_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 0 of federate__s3.nr_federate__s3, allocate an
                    // array of trigger pointers for downstream reactions through port federate__s3.nr_federate__s3.msg
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &federate__s3_nr_federate__s3_self[src_runtime]->base.allocations); 
                    federate__s3_nr_federate__s3_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges federate__s3.nr_federate__s3.msg(0,1)->[federate__s3.s3.AP_in(0,1)] and federate__s3.s3.AP_in(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range federate__s3.s3.AP_in(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port federate__s3.s3.AP_in's trigger struct.
                        federate__s3_nr_federate__s3_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &federate__s3_s3_self[dst_runtime]->_lf__AP_in;
                    }
                }
            }
        
        }
        // **** End of non-nested deferred initialize for federate__s3.nr_federate__s3
        // **** Start non-nested deferred initialize for federate__s3.nr_federate__s3_0
        {
        
            // For reference counting, set num_destinations for port federate__s3.nr_federate__s3_0.msg.
            // Iterate over range federate__s3.nr_federate__s3_0.msg(0,1)->[federate__s3.s3.AV_in(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3_nr_federate__s3_0_self[src_runtime]->_lf_msg._base.num_destinations = 1;
                federate__s3_nr_federate__s3_0_self[src_runtime]->_lf_msg._base.source_reactor = (self_base_t*)federate__s3_nr_federate__s3_0_self[src_runtime];
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range federate__s3.nr_federate__s3_0.msg(0,1)->[federate__s3.s3.AV_in(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 0 of federate__s3.nr_federate__s3_0 triggers 1 downstream reactions
                    // through port federate__s3.nr_federate__s3_0.msg.
                    federate__s3_nr_federate__s3_0_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 0 of federate__s3.nr_federate__s3_0, allocate an
                    // array of trigger pointers for downstream reactions through port federate__s3.nr_federate__s3_0.msg
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &federate__s3_nr_federate__s3_0_self[src_runtime]->base.allocations); 
                    federate__s3_nr_federate__s3_0_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges federate__s3.nr_federate__s3_0.msg(0,1)->[federate__s3.s3.AV_in(0,1)] and federate__s3.s3.AV_in(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range federate__s3.s3.AV_in(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port federate__s3.s3.AV_in's trigger struct.
                        federate__s3_nr_federate__s3_0_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &federate__s3_s3_self[dst_runtime]->_lf__AV_in;
                    }
                }
            }
        
        }
        // **** End of non-nested deferred initialize for federate__s3.nr_federate__s3_0
        // **** Start non-nested deferred initialize for federate__s3.nr_federate__s3_1
        {
        
            // For reference counting, set num_destinations for port federate__s3.nr_federate__s3_1.msg.
            // Iterate over range federate__s3.nr_federate__s3_1.msg(0,1)->[federate__s3.s3.CP_in(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3_nr_federate__s3_1_self[src_runtime]->_lf_msg._base.num_destinations = 1;
                federate__s3_nr_federate__s3_1_self[src_runtime]->_lf_msg._base.source_reactor = (self_base_t*)federate__s3_nr_federate__s3_1_self[src_runtime];
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range federate__s3.nr_federate__s3_1.msg(0,1)->[federate__s3.s3.CP_in(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 0 of federate__s3.nr_federate__s3_1 triggers 1 downstream reactions
                    // through port federate__s3.nr_federate__s3_1.msg.
                    federate__s3_nr_federate__s3_1_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 0 of federate__s3.nr_federate__s3_1, allocate an
                    // array of trigger pointers for downstream reactions through port federate__s3.nr_federate__s3_1.msg
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &federate__s3_nr_federate__s3_1_self[src_runtime]->base.allocations); 
                    federate__s3_nr_federate__s3_1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges federate__s3.nr_federate__s3_1.msg(0,1)->[federate__s3.s3.CP_in(0,1)] and federate__s3.s3.CP_in(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range federate__s3.s3.CP_in(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port federate__s3.s3.CP_in's trigger struct.
                        federate__s3_nr_federate__s3_1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &federate__s3_s3_self[dst_runtime]->_lf__CP_in;
                    }
                }
            }
        
        }
        // **** End of non-nested deferred initialize for federate__s3.nr_federate__s3_1
        // **** Start non-nested deferred initialize for federate__s3.nr_federate__s3_2
        {
        
            // For reference counting, set num_destinations for port federate__s3.nr_federate__s3_2.msg.
            // Iterate over range federate__s3.nr_federate__s3_2.msg(0,1)->[federate__s3.s3.CV_in(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3_nr_federate__s3_2_self[src_runtime]->_lf_msg._base.num_destinations = 1;
                federate__s3_nr_federate__s3_2_self[src_runtime]->_lf_msg._base.source_reactor = (self_base_t*)federate__s3_nr_federate__s3_2_self[src_runtime];
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range federate__s3.nr_federate__s3_2.msg(0,1)->[federate__s3.s3.CV_in(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 0 of federate__s3.nr_federate__s3_2 triggers 1 downstream reactions
                    // through port federate__s3.nr_federate__s3_2.msg.
                    federate__s3_nr_federate__s3_2_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 0 of federate__s3.nr_federate__s3_2, allocate an
                    // array of trigger pointers for downstream reactions through port federate__s3.nr_federate__s3_2.msg
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &federate__s3_nr_federate__s3_2_self[src_runtime]->base.allocations); 
                    federate__s3_nr_federate__s3_2_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges federate__s3.nr_federate__s3_2.msg(0,1)->[federate__s3.s3.CV_in(0,1)] and federate__s3.s3.CV_in(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range federate__s3.s3.CV_in(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port federate__s3.s3.CV_in's trigger struct.
                        federate__s3_nr_federate__s3_2_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &federate__s3_s3_self[dst_runtime]->_lf__CV_in;
                    }
                }
            }
        
        }
        // **** End of non-nested deferred initialize for federate__s3.nr_federate__s3_2
        // **** Start non-nested deferred initialize for federate__s3._s3AP_in0
        {
        
            // For reference counting, set num_destinations for port federate__s3._s3AP_in0.port.
            // Iterate over range federate__s3._s3AP_in0.port(0,1)->[federate__s3.s3.AP_in(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3__s3ap_in0_self[src_runtime]->_lf_port[src_channel]._base.num_destinations = 1;
                federate__s3__s3ap_in0_self[src_runtime]->_lf_port[src_channel]._base.source_reactor = (self_base_t*)federate__s3__s3ap_in0_self[src_runtime];
            }
        
        
        }
        // **** End of non-nested deferred initialize for federate__s3._s3AP_in0
        // **** Start non-nested deferred initialize for federate__s3._s3AV_in0
        {
        
            // For reference counting, set num_destinations for port federate__s3._s3AV_in0.port.
            // Iterate over range federate__s3._s3AV_in0.port(0,1)->[federate__s3.s3.AV_in(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3__s3av_in0_self[src_runtime]->_lf_port[src_channel]._base.num_destinations = 1;
                federate__s3__s3av_in0_self[src_runtime]->_lf_port[src_channel]._base.source_reactor = (self_base_t*)federate__s3__s3av_in0_self[src_runtime];
            }
        
        
        }
        // **** End of non-nested deferred initialize for federate__s3._s3AV_in0
        // **** Start non-nested deferred initialize for federate__s3._s3CP_in0
        {
        
            // For reference counting, set num_destinations for port federate__s3._s3CP_in0.port.
            // Iterate over range federate__s3._s3CP_in0.port(0,1)->[federate__s3.s3.CP_in(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3__s3cp_in0_self[src_runtime]->_lf_port[src_channel]._base.num_destinations = 1;
                federate__s3__s3cp_in0_self[src_runtime]->_lf_port[src_channel]._base.source_reactor = (self_base_t*)federate__s3__s3cp_in0_self[src_runtime];
            }
        
        
        }
        // **** End of non-nested deferred initialize for federate__s3._s3CP_in0
        // **** Start non-nested deferred initialize for federate__s3._s3CV_in0
        {
        
            // For reference counting, set num_destinations for port federate__s3._s3CV_in0.port.
            // Iterate over range federate__s3._s3CV_in0.port(0,1)->[federate__s3.s3.CV_in(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                federate__s3__s3cv_in0_self[src_runtime]->_lf_port[src_channel]._base.num_destinations = 1;
                federate__s3__s3cv_in0_self[src_runtime]->_lf_port[src_channel]._base.source_reactor = (self_base_t*)federate__s3__s3cv_in0_self[src_runtime];
            }
        
        
        }
        // **** End of non-nested deferred initialize for federate__s3._s3CV_in0
    }
    // **** End of non-nested deferred initialize for federate__s3
    // Connect inputs and outputs for reactor federate__s3.
    // Connect inputs and outputs for reactor federate__s3.s3.
    // Connect federate__s3.s3.AP_out(0,1)->[federate__s3.ns_federate__p3.msg(0,1)] to port federate__s3.ns_federate__p3.msg(0,1)
    // Iterate over ranges federate__s3.s3.AP_out(0,1)->[federate__s3.ns_federate__p3.msg(0,1)] and federate__s3.ns_federate__p3.msg(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range federate__s3.ns_federate__p3.msg(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            federate__s3_ns_federate__p3_self[dst_runtime]->_lf_msg[dst_channel] = (_networksender_0_0_msg_t*)&federate__s3_s3_self[src_runtime]->_lf_AP_out;
        }
    }
    // Connect federate__s3.s3.AV_out(0,1)->[federate__s3.ns_federate__p3_0.msg(0,1)] to port federate__s3.ns_federate__p3_0.msg(0,1)
    // Iterate over ranges federate__s3.s3.AV_out(0,1)->[federate__s3.ns_federate__p3_0.msg(0,1)] and federate__s3.ns_federate__p3_0.msg(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range federate__s3.ns_federate__p3_0.msg(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            federate__s3_ns_federate__p3_0_self[dst_runtime]->_lf_msg[dst_channel] = (_networksender_1_1_msg_t*)&federate__s3_s3_self[src_runtime]->_lf_AV_out;
        }
    }
    // Connect federate__s3.s3.CP_out(0,1)->[federate__s3.ns_federate__p3_1.msg(0,1)] to port federate__s3.ns_federate__p3_1.msg(0,1)
    // Iterate over ranges federate__s3.s3.CP_out(0,1)->[federate__s3.ns_federate__p3_1.msg(0,1)] and federate__s3.ns_federate__p3_1.msg(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range federate__s3.ns_federate__p3_1.msg(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            federate__s3_ns_federate__p3_1_self[dst_runtime]->_lf_msg[dst_channel] = (_networksender_2_2_msg_t*)&federate__s3_s3_self[src_runtime]->_lf_CP_out;
        }
    }
    // Connect federate__s3.s3.CV_out(0,1)->[federate__s3.ns_federate__p3_2.msg(0,1)] to port federate__s3.ns_federate__p3_2.msg(0,1)
    // Iterate over ranges federate__s3.s3.CV_out(0,1)->[federate__s3.ns_federate__p3_2.msg(0,1)] and federate__s3.ns_federate__p3_2.msg(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range federate__s3.ns_federate__p3_2.msg(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            federate__s3_ns_federate__p3_2_self[dst_runtime]->_lf_msg[dst_channel] = (_networksender_3_3_msg_t*)&federate__s3_s3_self[src_runtime]->_lf_CV_out;
        }
    }
    // Connect federate__s3.s3.request(0,1)->[federate__s3.ns_federate__plant_1.msg(0,1)] to port federate__s3.ns_federate__plant_1.msg(0,1)
    // Iterate over ranges federate__s3.s3.request(0,1)->[federate__s3.ns_federate__plant_1.msg(0,1)] and federate__s3.ns_federate__plant_1.msg(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range federate__s3.ns_federate__plant_1.msg(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            federate__s3_ns_federate__plant_1_self[dst_runtime]->_lf_msg[dst_channel] = (_networksender_4_4_msg_t*)&federate__s3_s3_self[src_runtime]->_lf_request;
        }
    }
    // Connect federate__s3.s3.sim_start_time(0,1)->[federate__s3.ns_federate__p3_3.msg(0,1)] to port federate__s3.ns_federate__p3_3.msg(0,1)
    // Iterate over ranges federate__s3.s3.sim_start_time(0,1)->[federate__s3.ns_federate__p3_3.msg(0,1)] and federate__s3.ns_federate__p3_3.msg(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range federate__s3.ns_federate__p3_3.msg(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            federate__s3_ns_federate__p3_3_self[dst_runtime]->_lf_msg[dst_channel] = (_networksender_5_5_msg_t*)&federate__s3_s3_self[src_runtime]->_lf_sim_start_time;
        }
    }
    // Connect inputs and outputs for reactor federate__s3.ns_federate__p3.
    // Connect inputs and outputs for reactor federate__s3.ns_federate__p3_0.
    // Connect inputs and outputs for reactor federate__s3.ns_federate__p3_1.
    // Connect inputs and outputs for reactor federate__s3.ns_federate__p3_2.
    // Connect inputs and outputs for reactor federate__s3.ns_federate__plant_1.
    // Connect inputs and outputs for reactor federate__s3.ns_federate__p3_3.
    // Connect inputs and outputs for reactor federate__s3.nr_federate__s3.
    // Connect federate__s3.nr_federate__s3.msg(0,1)->[federate__s3.s3.AP_in(0,1)] to port federate__s3.s3.AP_in(0,1)
    // Iterate over ranges federate__s3.nr_federate__s3.msg(0,1)->[federate__s3.s3.AP_in(0,1)] and federate__s3.s3.AP_in(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range federate__s3.s3.AP_in(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            federate__s3_s3_self[dst_runtime]->_lf_AP_in = (_sensor_AP_in_t*)&federate__s3_nr_federate__s3_self[src_runtime]->_lf_msg;
        }
    }
    // Connect inputs and outputs for reactor federate__s3.nr_federate__s3_0.
    // Connect federate__s3.nr_federate__s3_0.msg(0,1)->[federate__s3.s3.AV_in(0,1)] to port federate__s3.s3.AV_in(0,1)
    // Iterate over ranges federate__s3.nr_federate__s3_0.msg(0,1)->[federate__s3.s3.AV_in(0,1)] and federate__s3.s3.AV_in(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range federate__s3.s3.AV_in(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            federate__s3_s3_self[dst_runtime]->_lf_AV_in = (_sensor_AV_in_t*)&federate__s3_nr_federate__s3_0_self[src_runtime]->_lf_msg;
        }
    }
    // Connect inputs and outputs for reactor federate__s3.nr_federate__s3_1.
    // Connect federate__s3.nr_federate__s3_1.msg(0,1)->[federate__s3.s3.CP_in(0,1)] to port federate__s3.s3.CP_in(0,1)
    // Iterate over ranges federate__s3.nr_federate__s3_1.msg(0,1)->[federate__s3.s3.CP_in(0,1)] and federate__s3.s3.CP_in(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range federate__s3.s3.CP_in(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            federate__s3_s3_self[dst_runtime]->_lf_CP_in = (_sensor_CP_in_t*)&federate__s3_nr_federate__s3_1_self[src_runtime]->_lf_msg;
        }
    }
    // Connect inputs and outputs for reactor federate__s3.nr_federate__s3_2.
    // Connect federate__s3.nr_federate__s3_2.msg(0,1)->[federate__s3.s3.CV_in(0,1)] to port federate__s3.s3.CV_in(0,1)
    // Iterate over ranges federate__s3.nr_federate__s3_2.msg(0,1)->[federate__s3.s3.CV_in(0,1)] and federate__s3.s3.CV_in(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range federate__s3.s3.CV_in(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            federate__s3_s3_self[dst_runtime]->_lf_CV_in = (_sensor_CV_in_t*)&federate__s3_nr_federate__s3_2_self[src_runtime]->_lf_msg;
        }
    }
    // Connect inputs and outputs for reactor federate__s3._s3AP_in0.
    // Connect inputs and outputs for reactor federate__s3._s3AV_in0.
    // Connect inputs and outputs for reactor federate__s3._s3CP_in0.
    // Connect inputs and outputs for reactor federate__s3._s3CV_in0.
    {
    }
    {
    }
    {
    }
    {
    }
    {
    }
    {
    }
    {
    }
    {
        // Add action federate__s3.nr_federate__s3.networkMessage to array of is_present fields.
        envs[federate__s3_main].is_present_fields[0 + (0) * 1]
                = (bool *) &federate__s3_nr_federate__s3_self[0]->_lf__networkMessage.status;
        #ifdef FEDERATED_DECENTRALIZED
        // Add action federate__s3.nr_federate__s3.networkMessage to array of intended_tag fields.
        envs[federate__s3_main]._lf_intended_tag_fields[0 + (0) * 1]
                = &federate__s3_nr_federate__s3_self[0]->_lf_networkMessage.intended_tag;
        #endif // FEDERATED_DECENTRALIZED
    }
    {
        // Add action federate__s3.nr_federate__s3_0.networkMessage to array of is_present fields.
        envs[federate__s3_main].is_present_fields[1 + (0) * 1]
                = (bool *) &federate__s3_nr_federate__s3_0_self[0]->_lf__networkMessage.status;
        #ifdef FEDERATED_DECENTRALIZED
        // Add action federate__s3.nr_federate__s3_0.networkMessage to array of intended_tag fields.
        envs[federate__s3_main]._lf_intended_tag_fields[1 + (0) * 1]
                = &federate__s3_nr_federate__s3_0_self[0]->_lf_networkMessage.intended_tag;
        #endif // FEDERATED_DECENTRALIZED
    }
    {
        // Add action federate__s3.nr_federate__s3_1.networkMessage to array of is_present fields.
        envs[federate__s3_main].is_present_fields[2 + (0) * 1]
                = (bool *) &federate__s3_nr_federate__s3_1_self[0]->_lf__networkMessage.status;
        #ifdef FEDERATED_DECENTRALIZED
        // Add action federate__s3.nr_federate__s3_1.networkMessage to array of intended_tag fields.
        envs[federate__s3_main]._lf_intended_tag_fields[2 + (0) * 1]
                = &federate__s3_nr_federate__s3_1_self[0]->_lf_networkMessage.intended_tag;
        #endif // FEDERATED_DECENTRALIZED
    }
    {
        // Add action federate__s3.nr_federate__s3_2.networkMessage to array of is_present fields.
        envs[federate__s3_main].is_present_fields[3 + (0) * 1]
                = (bool *) &federate__s3_nr_federate__s3_2_self[0]->_lf__networkMessage.status;
        #ifdef FEDERATED_DECENTRALIZED
        // Add action federate__s3.nr_federate__s3_2.networkMessage to array of intended_tag fields.
        envs[federate__s3_main]._lf_intended_tag_fields[3 + (0) * 1]
                = &federate__s3_nr_federate__s3_2_self[0]->_lf_networkMessage.intended_tag;
        #endif // FEDERATED_DECENTRALIZED
    }
    {
    }
    {
    }
    {
    }
    {
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            // Add output port federate__s3.s3.AP_out to array of is_present fields.
            envs[federate__s3_main].is_present_fields[(0) * 6 + 4 + count] = &federate__s3_s3_self[0]->_lf_AP_out.is_present;
            #ifdef FEDERATED_DECENTRALIZED
            // Add output port federate__s3.s3.AP_out to array of intended_tag fields.
            envs[federate__s3_main]._lf_intended_tag_fields[(0) * 6 + 4 + count] = &federate__s3_s3_self[0]->_lf_AP_out.intended_tag;
            #endif // FEDERATED_DECENTRALIZED
            count++;
            // Add output port federate__s3.s3.AV_out to array of is_present fields.
            envs[federate__s3_main].is_present_fields[(0) * 6 + 4 + count] = &federate__s3_s3_self[0]->_lf_AV_out.is_present;
            #ifdef FEDERATED_DECENTRALIZED
            // Add output port federate__s3.s3.AV_out to array of intended_tag fields.
            envs[federate__s3_main]._lf_intended_tag_fields[(0) * 6 + 4 + count] = &federate__s3_s3_self[0]->_lf_AV_out.intended_tag;
            #endif // FEDERATED_DECENTRALIZED
            count++;
            // Add output port federate__s3.s3.CP_out to array of is_present fields.
            envs[federate__s3_main].is_present_fields[(0) * 6 + 4 + count] = &federate__s3_s3_self[0]->_lf_CP_out.is_present;
            #ifdef FEDERATED_DECENTRALIZED
            // Add output port federate__s3.s3.CP_out to array of intended_tag fields.
            envs[federate__s3_main]._lf_intended_tag_fields[(0) * 6 + 4 + count] = &federate__s3_s3_self[0]->_lf_CP_out.intended_tag;
            #endif // FEDERATED_DECENTRALIZED
            count++;
            // Add output port federate__s3.s3.CV_out to array of is_present fields.
            envs[federate__s3_main].is_present_fields[(0) * 6 + 4 + count] = &federate__s3_s3_self[0]->_lf_CV_out.is_present;
            #ifdef FEDERATED_DECENTRALIZED
            // Add output port federate__s3.s3.CV_out to array of intended_tag fields.
            envs[federate__s3_main]._lf_intended_tag_fields[(0) * 6 + 4 + count] = &federate__s3_s3_self[0]->_lf_CV_out.intended_tag;
            #endif // FEDERATED_DECENTRALIZED
            count++;
            // Add output port federate__s3.s3.request to array of is_present fields.
            envs[federate__s3_main].is_present_fields[(0) * 6 + 4 + count] = &federate__s3_s3_self[0]->_lf_request.is_present;
            #ifdef FEDERATED_DECENTRALIZED
            // Add output port federate__s3.s3.request to array of intended_tag fields.
            envs[federate__s3_main]._lf_intended_tag_fields[(0) * 6 + 4 + count] = &federate__s3_s3_self[0]->_lf_request.intended_tag;
            #endif // FEDERATED_DECENTRALIZED
            count++;
            // Add output port federate__s3.s3.sim_start_time to array of is_present fields.
            envs[federate__s3_main].is_present_fields[(0) * 6 + 4 + count] = &federate__s3_s3_self[0]->_lf_sim_start_time.is_present;
            #ifdef FEDERATED_DECENTRALIZED
            // Add output port federate__s3.s3.sim_start_time to array of intended_tag fields.
            envs[federate__s3_main]._lf_intended_tag_fields[(0) * 6 + 4 + count] = &federate__s3_s3_self[0]->_lf_sim_start_time.intended_tag;
            #endif // FEDERATED_DECENTRALIZED
            count++;
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            // Add output port federate__s3.nr_federate__s3.msg to array of is_present fields.
            envs[federate__s3_main].is_present_fields[(0) * 1 + 10 + count] = &federate__s3_nr_federate__s3_self[0]->_lf_msg.is_present;
            #ifdef FEDERATED_DECENTRALIZED
            // Add output port federate__s3.nr_federate__s3.msg to array of intended_tag fields.
            envs[federate__s3_main]._lf_intended_tag_fields[(0) * 1 + 10 + count] = &federate__s3_nr_federate__s3_self[0]->_lf_msg.intended_tag;
            #endif // FEDERATED_DECENTRALIZED
            count++;
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            // Add output port federate__s3.nr_federate__s3_0.msg to array of is_present fields.
            envs[federate__s3_main].is_present_fields[(0) * 1 + 11 + count] = &federate__s3_nr_federate__s3_0_self[0]->_lf_msg.is_present;
            #ifdef FEDERATED_DECENTRALIZED
            // Add output port federate__s3.nr_federate__s3_0.msg to array of intended_tag fields.
            envs[federate__s3_main]._lf_intended_tag_fields[(0) * 1 + 11 + count] = &federate__s3_nr_federate__s3_0_self[0]->_lf_msg.intended_tag;
            #endif // FEDERATED_DECENTRALIZED
            count++;
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            // Add output port federate__s3.nr_federate__s3_1.msg to array of is_present fields.
            envs[federate__s3_main].is_present_fields[(0) * 1 + 12 + count] = &federate__s3_nr_federate__s3_1_self[0]->_lf_msg.is_present;
            #ifdef FEDERATED_DECENTRALIZED
            // Add output port federate__s3.nr_federate__s3_1.msg to array of intended_tag fields.
            envs[federate__s3_main]._lf_intended_tag_fields[(0) * 1 + 12 + count] = &federate__s3_nr_federate__s3_1_self[0]->_lf_msg.intended_tag;
            #endif // FEDERATED_DECENTRALIZED
            count++;
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            // Add output port federate__s3.nr_federate__s3_2.msg to array of is_present fields.
            envs[federate__s3_main].is_present_fields[(0) * 1 + 13 + count] = &federate__s3_nr_federate__s3_2_self[0]->_lf_msg.is_present;
            #ifdef FEDERATED_DECENTRALIZED
            // Add output port federate__s3.nr_federate__s3_2.msg to array of intended_tag fields.
            envs[federate__s3_main]._lf_intended_tag_fields[(0) * 1 + 13 + count] = &federate__s3_nr_federate__s3_2_self[0]->_lf_msg.intended_tag;
            #endif // FEDERATED_DECENTRALIZED
            count++;
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
        }
    }
    
    // Set reaction priorities for ReactorInstance federate__s3
    {
    
        // Set reaction priorities for ReactorInstance federate__s3.s3
        {
            // index is the OR of level 0 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_s3_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
            // index is the OR of level 4 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_s3_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 4);
            // index is the OR of level 5 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_s3_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 5);
            // index is the OR of level 6 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_s3_self[0]->_lf__reaction_3.index = lf_combine_deadline_and_level(9223372036854775807, 6);
            // index is the OR of level 7 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_s3_self[0]->_lf__reaction_4.index = lf_combine_deadline_and_level(9223372036854775807, 7);
        }
    
    
        // Set reaction priorities for ReactorInstance federate__s3.ns_federate__p3
        {
            // index is the OR of level 7 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 7);
            // index is the OR of level 8 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 8);
            // index is the OR of level 9 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 9);
        }
    
    
        // Set reaction priorities for ReactorInstance federate__s3.ns_federate__p3_0
        {
            // index is the OR of level 10 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_0_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 10);
            // index is the OR of level 11 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_0_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 11);
            // index is the OR of level 12 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_0_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 12);
        }
    
    
        // Set reaction priorities for ReactorInstance federate__s3.ns_federate__p3_1
        {
            // index is the OR of level 13 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_1_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 13);
            // index is the OR of level 14 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_1_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 14);
            // index is the OR of level 15 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_1_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 15);
        }
    
    
        // Set reaction priorities for ReactorInstance federate__s3.ns_federate__p3_2
        {
            // index is the OR of level 16 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_2_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 16);
            // index is the OR of level 17 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_2_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 17);
            // index is the OR of level 18 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_2_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 18);
        }
    
    
        // Set reaction priorities for ReactorInstance federate__s3.ns_federate__plant_1
        {
            // index is the OR of level 0 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__plant_1_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
            // index is the OR of level 1 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__plant_1_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 1);
            // index is the OR of level 2 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__plant_1_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 2);
        }
    
    
        // Set reaction priorities for ReactorInstance federate__s3.ns_federate__p3_3
        {
            // index is the OR of level 0 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_3_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
            // index is the OR of level 1 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_3_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 1);
            // index is the OR of level 2 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_ns_federate__p3_3_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 2);
        }
    
    
        // Set reaction priorities for ReactorInstance federate__s3.nr_federate__s3
        {
            // index is the OR of level 3 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_nr_federate__s3_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 3);
        }
    
    
        // Set reaction priorities for ReactorInstance federate__s3.nr_federate__s3_0
        {
            // index is the OR of level 4 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_nr_federate__s3_0_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 4);
        }
    
    
        // Set reaction priorities for ReactorInstance federate__s3.nr_federate__s3_1
        {
            // index is the OR of level 5 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_nr_federate__s3_1_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 5);
        }
    
    
        // Set reaction priorities for ReactorInstance federate__s3.nr_federate__s3_2
        {
            // index is the OR of level 6 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            federate__s3_nr_federate__s3_2_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 6);
        }
    
    }
    
    // Initialize the scheduler
    size_t num_reactions_per_level[19] = 
        {3, 2, 2, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    sched_params_t sched_params = (sched_params_t) {
                            .num_reactions_per_level = &num_reactions_per_level[0],
                            .num_reactions_per_level_size = (size_t) 19};
    lf_sched_init(
        &envs[federate__s3_main],
        envs[federate__s3_main].num_workers,
        &sched_params
    );
    #ifdef EXECUTABLE_PREAMBLE
    _lf_executable_preamble(&envs[0]);
    #endif
    #ifdef FEDERATED
    initialize_triggers_for_federate();
    #endif // FEDERATED
}
void logical_tag_complete(tag_t tag_to_send) {
 #ifdef FEDERATED_CENTRALIZED
     lf_latest_tag_confirmed(tag_to_send);
 #else
     (void) tag_to_send;
 #endif // FEDERATED_CENTRALIZED

}
#ifndef FEDERATED
void lf_terminate_execution(environment_t* env) {
    (void) env;
}
#endif
